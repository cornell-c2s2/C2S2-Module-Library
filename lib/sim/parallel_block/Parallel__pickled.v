//-------------------------------------------------------------------------
// Parallel.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL VerilogPlaceholder ParallelVRTL Definition
// Full name: ParallelVRTL__dib_1__dobreg_2__N_32
// At /home/vml37/c2s2/parallel2/rtl_design/sim/parallel/ParallelVRTL.py

//***********************************************************
// Pickled source file of placeholder ParallelVRTL__dib_1__dobreg_2__N_32
//***********************************************************

//-----------------------------------------------------------
// Dependency of placeholder ParallelVRTL
//-----------------------------------------------------------

`ifndef PARALLELVRTL
`define PARALLELVRTL

// The source code below are included because they are specified
// as the v_libs Verilog placeholder option of component ParallelVRTL__dib_1__dobreg_2__N_32.

// If you get a duplicated def error from files included below, please
// make sure they are included either through the v_libs option or the
// explicit `include statement in the Verilog source code -- if they
// appear in both then they will be included twice!


// End of all v_libs files for component ParallelVRTL__dib_1__dobreg_2__N_32

`line 1 "ParallelVRTL.v" 0
module ParallelVRTL
#(
	parameter dib = 1,					//decoder inputs
    parameter dobreg = 1'b1 << dib, 	//number of outputs to decoder/#of registers
	parameter N = 32
)(
	input logic clk, 
	input logic reset,
	input logic VIN, 
	input logic RIN, 
	input logic [N-1:0] dta,

	output logic EN, 
	output logic VOUT, 
	output logic ROUT,
	output logic [dobreg-1:0] DOUT,
	output logic [dib-1:0] DSEL,
	output logic [N-1:0] OUTPUTA, 
	output logic [N-1:0] OUTPUTB
);
    //body of code
	ControlVRTL c
		(
			.vin(VIN),
			.rin(RIN),
			.vout(VOUT),
			.rout(ROUT),
			.dsel(DSEL),
			.reset(reset),
			.EN(EN)
		);

	DecoderVRTL #(.m(dib), .n(dobreg)) d
		(
			.enable(EN),
			.x(DSEL),
			.y(DOUT)
		);      

	RegisterV #(.N(N)) a
		(
			.clk(clk),
			.reset(reset),
			.w((DOUT[0]) ? 0 : 1),
			.d(dta),
			.q(OUTPUTA)
		);
	
	RegisterV #(.N(N)) b
		(
			.clk(clk),
			.reset(reset),
			.w(DOUT[1]),
			.d(dta),
			.q(OUTPUTB)
		);
endmodule



module RegisterV
	#(parameter N = 32)
	(clk, reset, w, d, q);

	input logic clk;
	input logic reset;
	input  logic w;
	input logic [N-1:0] d;
	output logic [N-1:0] q;
	logic [N-1:0] regout;

	assign q = regout;

	always @(posedge clk) begin
		if (w == 1)
			regout <= d;
	end
endmodule

module DecoderVRTL 
#(
	parameter m = 3,
	parameter n = 1'b1 << m  // n = 2 ** m
)(
`ifdef USE_POWER_PINS
	inout vccd1,
	inout vssd1,
`endif

	input enable,
	input  reg [m-1:0] x,
	output reg [n-1:0] y
);
	always @(*)
		if (!enable)
			y = {n {1'b0}};
		else
			y = {{n - 1 {1'b0}}, 1'b1} << x;
endmodule


module ControlVRTL 
#(
    parameter dib = 1,
    parameter dobreg = 1'b1 << dib
)(
    input   logic vin,
    input   logic rin,
    input   logic reset,

    output  logic vout,
    output  logic rout,
    output  logic EN,
    output  logic [dib-1:0] dsel
);
    logic [dobreg-1'b1:0] count;
    always @(*) begin 
        if (reset == 1'b1)begin
            dsel  =  0;
            EN    =  1'b0; 
            vout  =  1'b0;//1'b0
            rout  =  1'b0;
            count =  0;
        end
        else if ((vin==1) & (rin==1))begin 
            dsel = count;
            EN = 1'b1;
            rout = 1'b1;
            if (dsel == (dobreg - 1))begin 
                vout = 1'b1;
            end 
            else begin
                vout = 1'b0;
            end
            count = count + 1;
        end
        else begin
            dsel = 0;
            EN   = 1'b0; 
            vout = 1'b0;
            rout = 1'b0;
            count = count;
        end
    end
endmodule





//generate block instantiation
// mydesign #(.dob(dobreg)) e
// 	(
// 		.clk(CLK),
// 		.reset(RESET),
// 		.w(DOUT[dobreg-1]),
// 		.d(DATA),
// 		.q(OUTPUT)
// 	);

//generate block for loop
// module my_design
// 	#(parameter dob=2)
// 	(input [dob-1:0] clk, reset, w, d
// 	 output [dob-1:0] q);

// 	genvar i;
// 	generate
// 		for(i=0; i<N; i=i+1) begin
// 			RegisterV u0(clk[i], rest[i], w[i], d[i], q[i]);
// 		end
// 	endgenerate
// endmodule hello
`endif /* PARALLELVRTL */
//-----------------------------------------------------------
// Wrapper of placeholder ParallelVRTL__dib_1__dobreg_2__N_32
//-----------------------------------------------------------

`ifndef PARALLELVRTL__DIB_1__DOBREG_2__N_32
`define PARALLELVRTL__DIB_1__DOBREG_2__N_32

module Parallel
(
  output logic [2-1:0] DOUT ,
  output logic [1-1:0] DSEL ,
  output logic [1-1:0] EN ,
  output logic [2-1:0] OUTPUTA ,
  output logic [2-1:0] OUTPUTB ,
  input logic [1-1:0] RIN ,
  output logic [1-1:0] ROUT ,
  input logic [1-1:0] VIN ,
  output logic [1-1:0] VOUT ,
  input logic [1-1:0] clk ,
  input logic [32-1:0] dta ,
  input logic [1-1:0] reset 
);
  ParallelVRTL
  #(
    .dib( 1 ),
    .dobreg( 2 ),
    .N( 32 )
  ) v
  (
    .DOUT( DOUT ),
    .DSEL( DSEL ),
    .EN( EN ),
    .OUTPUTA( OUTPUTA ),
    .OUTPUTB( OUTPUTB ),
    .RIN( RIN ),
    .ROUT( ROUT ),
    .VIN( VIN ),
    .VOUT( VOUT ),
    .clk( clk ),
    .dta( dta ),
    .reset( reset )
  );
endmodule

`endif /* PARALLELVRTL__DIB_1__DOBREG_2__N_32 */

